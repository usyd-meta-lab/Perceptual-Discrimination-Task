<!DOCTYPE html>
<html>
<head>
  <title>USYD Meta Lab</title>
  <link rel="icon" type="image/x-icon" href="https://usyd-meta-lab.github.io/favicon-32x32.png">

  <!-- Load jsPsych and dependencies -->
  <script src="https://unpkg.com/jspsych@8.2.1"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/foundation/5.5.2/js/foundation.min.js"></script>
  <link href="https://unpkg.com/jspsych@8.2.1/css/jspsych.css" rel="stylesheet" type="text/css" />
  <link href="https://unpkg.com/jquery-ui-css@1.11.5/jquery-ui.css" rel="stylesheet" type="text/css" />

  <!-- Load jsPsych plugins -->
  <script src="https://unpkg.com/@jspsych/plugin-instructions@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-text@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-external-html@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-preload@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-slider-response@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-browser-check@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-canvas-keyboard-response@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-call-function@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-fullscreen@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-likert@2.1.0"></script>
  <script src="https://unpkg.com/@jspsych-contrib/plugin-pipe"></script>

  <!-- Load the global environment and additional scripts -->
  <script src="https://usyd-meta-lab.github.io/files/info_sheets.js"></script>



  <!-- Custom CSS -->
  <link href="custom-css.css" rel="stylesheet" type="text/css" />

  <style> 
    body {
      background-color: #A3A3A3;
    }
  </style>
</style>
</head>

<body></body>

<script>




/* 

/* 
  ===============================================================
  =              GLOBAL SETTINGS & INITIALIZATION               =
  ===============================================================
*/

// Initialize jsPsych
  const jsPsych = initJsPsych({
    on_interaction_data_update: function(data) {
    // If participant exits fullscreen, note it (unless it's a pilot).
      if (data.event === 'fullscreenexit' && pilot !== 'true') {
        in_fullscreen = false;
      }
    },
    on_finish: function(data) {
    // If user is forced to abort (wrong browser or device), show alert
      if (aborted === true) {
        alert("You must use Chrome or Firefox to complete this experiment.");
      }


      if (aborted === false) {

      // If not aborted, first save total time and then check average accuracy from summary trials
        var start_time = jsPsych.getStartTime();
        jsPsych.data.addProperties({ start_time: start_time });
        var total_time = jsPsych.getTotalTime();
        jsPsych.data.addProperties({ total_time: total_time });


      // Turn on to save a local copy
      //jsPsych.data.get().localSave('csv','mydata.csv'); 

        const meanCorrect = jsPsych.data.get().filter({trial_type: "Summary Trial"}).select('correct').mean();
        if (meanCorrect < 0.55) {
        // Failed check
          window.location = attention_redirect_link;
        } else {
        // Passed check
          window.location = redirect_link;
        }
      }
    }
  });

/**
 * These variables can be modified as needed:
 * - DataPipe_ID:         The DataPipe ID to which the data will be saved.
 * - SONA/prolific info:  Used for setting up redirect links.
 * - Task parameters:     Number of trials, blocks etc.
 */
const DataPipe_ID = "vmuVgxxOMTlT";  // The DataPipe ID for where the data should be stored
const sona_experiment_id = "NA";      // The SONA experiment ID 
const sona_credit_token = "NA";       // The SONA credit token 
const Prolific_redirect = "CHGWKNI0"; // The Prolific redirect link (to credit)
const Prolific_failed_check = "C13PIUOF"; // The Prolific redirect link for failing an attention check
const task_time = 30; // (minutes) for the PIS



// Task parameters: 
let no_trials = 42;         // Number of trials in each main block
let no_practice_trials = 25;// Number of practice trials
let total_blocks = 5;       // Total number of blocks (only used for instructions)
let dots_diff = 4.25;       // Starting difficulty (log-space)
let in_fullscreen = true;   // Tracks whether participant is in fullscreen
let provide_feedback;       // Tracks feedback mode (true during practice, false in test blocks)
let trialnum = 1;           // Trial counter
let blocknum = 1;           // Block counter
let aborted = false;        // Whether user was aborted from experiment
let phase = null;           // Tracks current phase: "Practice" or "Test"


   // The staircase is stored in log-space.
    // Starting value 4.2 corresponds to an increment of ~70 dots.
var staircase = {
  current_log: dots_diff,
  consecutive_correct: 0
};



/* 
  ===============================================================
  =               UTILITY & DRAWING FUNCTIONS                   =
  ===============================================================
*/



/**
 * Draws a specified number of random dots within a square area on a canvas.
 *
 * The function divides the given square (starting at the top-left corner defined by
 * boxX and boxY, with a total width/height defined by boxSize) into a grid of 25 rows
 * and 25 columns (625 positions). It then creates an array of all potential cell positions within the grid,
 * shuffles these positions, selects the first numDots positions, and draws a white filled circle 
 * (dot) at the center of each selected cell.
 *
 * @param {CanvasRenderingContext2D} ctx - The canvas rendering context used for drawing.
 * @param {number} boxX - The x-coordinate of the top-left corner of the square area.
 * @param {number} boxY - The y-coordinate of the top-left corner of the square area.
 * @param {number} boxSize - The width and height of the square area.
 * @param {number} numDots - The number of dots to draw.
 */


function drawDots(ctx, boxX, boxY, boxSize, numDots) {
      var gridSize = 25;              // 25 columns and 25 rows
      var cellSize = boxSize / gridSize; // Each cell's width (and height)
      var positions = [];
      // Create an array of all possible cell positions.
      for (var i = 0; i < gridSize; i++){
        for (var j = 0; j < gridSize; j++){
          positions.push({x: boxX + j * cellSize, y: boxY + i * cellSize});
        }
      }
      // Shuffle the array to randomize the positions.
      positions = jsPsych.randomization.repeat(positions, 1);
      // Select the first numDots positions.
      var selected = positions.slice(0, numDots);
      // Draw a white filled circle (dot) at the center of each selected cell.
      ctx.fillStyle = 'white';
      selected.forEach(function(pos) {
        var centerX = pos.x + cellSize / 2;
        var centerY = pos.y + cellSize / 2;
        var radius = cellSize / 3; // Adjust the radius as needed.
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.fill();
      });
    }



/**
 * Draws stimuli on a canvas element by rendering two boxes and, optionally, drawing dots within them.
 *
 * The function creates two boxes—one on the left and one on the right—with predetermined positions
 * and sizes. It fills each box with the specified colors. If the `dotsOn` flag is true, the function
 * draws a specified number of dots within each box using a grid-based approach (via the drawDots function).
 *
 * @param {HTMLCanvasElement} c - The canvas element on which the stimuli will be drawn.
 * @param {boolean} dotsOn - Determines whether to draw dots inside the boxes. If true, dots are drawn.
 * @param {string} leftboxFill - The fill color for the left box (e.g., "#000000" for black).
 * @param {string} rightboxFill - The fill color for the right box.
 * @param {number} leftDots - The number of dots to draw in the left box.
 * @param {number} rightDots - The number of dots to draw in the right box.
 */


    function drawStimuli(c, dotsOn, leftboxFill, rightboxFill, leftDots, rightDots){

      var ctx = c.getContext('2d');
      var canvas = c;


  // Define positions and size for left and right boxes.
      var leftBox = { x: 200, y: 250, size: 250 };
      var rightBox = { x: 550, y: 250, size: 250 };

        // Draw both boxes as black rectangles.
      ctx.fillStyle = leftboxFill;
      ctx.fillRect(leftBox.x, leftBox.y, leftBox.size, leftBox.size);
      ctx.fillStyle = rightboxFill;
      ctx.fillRect(rightBox.x, rightBox.y, rightBox.size, rightBox.size);


      if(dotsOn){
        // Draw the dots on each box.
        // The dots are drawn using a grid of 25 rows × 25 columns (625 cells)
        // so that dots will occupy distinct positions.
        drawDots(ctx, leftBox.x, leftBox.y, leftBox.size, leftDots);
        drawDots(ctx, rightBox.x, rightBox.y, rightBox.size, rightDots);

      }

    }







/* 
  ===============================================================
  =                        INSTRUCTIONS                          =
  ===============================================================
*/

/**
 * Instructions displayed before practice trials begin.
 * Will depend on whether confidence ratings are turned on or off.
 */
    const instructions = {
      type: jsPsychInstructions,
      pages: [
        `<p class="instructions">Welcome to the task!</p>
         <p class="instructions">In this task, you will judge which of two images contains more dots, then rate your confidence in your judgment.</p>
         <p class="instructions">A black cross will appear first; focus on it. Two boxes with a certain number of white dots will flash. Then, choose which box had more dots.</p>
         <p class="instructions"><strong>Press W</strong> if the <strong>left</strong> box had more dots, or <strong>E</strong> if the <strong>right</strong> box had more dots.</p>
         <p class="instructions">You will then rate your confidence in that judgment using a scale.</p>
        <p class="instructions">Use the entire scale from &apos;Guessing&apos; to &apos;Certain.&apos;</p>`,

        `<p class="instructions">Let&#39;s do some practice trials. Respond only after the dots have disappeared.</p>
         <p class="instructions">During practice, you will see feedback indicating correct or incorrect judgments.</p>
        <p class="instructions">No confidence rating is needed during these practice trials.</p>`
      ],
      show_clickable_nav: true
    };

/**
 * Instructions after practice finishes (explaining that no feedback will be given in the real task).
 */
    const practice_end = {
      type: jsPsychInstructions,
      pages: function() {
        if (ratings_on) {
          return [
            `<p class="instructions">In the real task, you will not see accuracy feedback. Instead, the box you choose will be outlined in <font color="blue">blue</font>.</p>
            <p class="instructions">You will then be asked to rate your confidence on a scale, which we will explain next.</p>`
          ];
        } else {
          return [
            `<p class="instructions">In the real task, you will not see accuracy feedback. The box you choose will simply be outlined in <font color="blue">blue</font>.</p>`
          ];
        }
      },
      show_clickable_nav: true
    };

/**
 * Instructions about confidence scale appear only if confidence ratings are on.
 */
    const conf_instruc = {
      timeline: [
        {
          type: jsPsychHtmlSliderResponse,
          css_classes: ["conf_instructions"],
          stimulus: function() {
            const header = jsPsych.timelineVariable('header');
            return `<div id="header" style="position: relative;">${header}</div><br><br>
          <div id="Iconf1" class="conf_ins" style="height: 25px; width: 154px; margin-top: 2px; margin-left: 15px;"></div>
          <div id="Iconf2" class="conf_ins" style="height: 25px; width: 154px; margin-top: 2px; margin-left: 169px;"></div>
          <div id="Iconf3" class="conf_ins" style="height: 25px; width: 154px; margin-top: 2px; margin-left: 323px;"></div>
          <div id="Iconf4" class="conf_ins" style="height: 25px; width: 154px; margin-top: 2px; margin-left: 477px;"></div>
            <div id="Iconf5" class="conf_ins" style="height: 25px; width: 154px; margin-top: 2px; margin-left: 631px;"></div>`;
          },
          on_load: function() {
        // Centers the slider segments
            const w = window.innerWidth;
            const marLeft = (w - 800) / 2;
            document.getElementById("Iconf1").style.left = marLeft + "px";
            document.getElementById("Iconf2").style.left = marLeft + "px";
            document.getElementById("Iconf3").style.left = marLeft + "px";
            document.getElementById("Iconf4").style.left = marLeft + "px";
            document.getElementById("Iconf5").style.left = marLeft + "px";

        // Possibly disable movement if needed
            const elementx = document.getElementById("jspsych-html-slider-response-response");
            elementx.disabled = jsPsych.timelineVariable('disable');
          },
          min: 1,
          max: 6,
          step: 1,
          slider_start: jsPsych.timelineVariable('start'),
          slider_width: 800,
          labels: ['Guessing', '', '', '', '', 'Certain'],
          button_label: "Submit",
          require_movement: jsPsych.timelineVariable('require')
        }
      ],
      timeline_variables: [
        {
          start: 3, require: true, disable: false,
          header: `A rating scale as shown below is used throughout the task. 
        You will select any point with your mouse.<br>Choose any point on the 
          scale and click &apos;Submit&apos; to continue.`
        },
        {
          start: 6, require: false, disable: true,
          header: `During the task, if you are <strong>very sure</strong> that you made 
          the correct judgment, you should respond <strong>&apos;Certain&apos;</strong>.`
        },
        {
          start: 1, require: false, disable: true,
          header: `<p class="instructions">If you are <strong>very unsure</strong>, 
          you should respond <strong>&apos;Guessing&apos;</strong>.</p>`
        },
        {
          start: 4, require: true, disable: false,
          header: `<p class="instructions">If you are <strong>somewhat sure</strong>, 
        you should select a rating between these extremes.</p>
        <p class="instructions">If you understand how to use the entire scale,
          choose any point and click &apos;Submit&apos; to continue.</p>`
        }
      ],
      conditional_function: function() {
        return ratings_on === true;
      }
    };

/**
 * Instructions displayed before starting the main (test) blocks.
 */
    const test_start = {
      type: jsPsychInstructions,
      pages: function() {
        if (ratings_on) {
          return [
            `<p class="instructions">The task is divided into ${total_blocks} blocks of ${no_trials} trials. 
          You can take short breaks between blocks.</p>
         <p class="instructions">There are no time limits on your responses or on your confidence ratings.</p>
         <p class="instructions"><strong>Press W</strong> if the <strong>left</strong> box had more dots, 
            or <strong>E</strong> if the <strong>right</strong> box had more dots.</p>`
          ];
        } else {
          return [
            `<p class="instructions">The task is divided into ${total_blocks} blocks of ${no_trials} trials. 
          You can take short breaks between blocks.</p>
         <p class="instructions">There is no time limit on your dot responses.</p>
         <p class="instructions"><strong>Press W</strong> if the <strong>left</strong> box had more dots, 
            or <strong>E</strong> if the <strong>right</strong> box had more dots.</p>`
          ];
        }
      },
      show_clickable_nav: true
    };

/**
 * Intermediate instruction that appears between blocks in the main task,
 * reminding participants that they can take a break.
 */
    const new_block = {
      type: jsPsychInstructions,
      pages: function() {
        return [
          `<p class="instructions">Block ${blocknum} of ${total_blocks} complete.<br><br>
       You can pause for a break now.<br><br>
       Remember:<br><strong>W</strong> if the <strong>left</strong> box had more dots,<br>
          <strong>E</strong> if the <strong>right</strong> box had more dots.</p>`
        ];
      },
      show_clickable_nav: true,
      on_finish: function() {
        blocknum++;
      }
    };



/* 
  ===============================================================
  =                 BROWSER & FULLSCREEN CHECKS                 =
  ===============================================================
*/

// Check that participant is using Chrome or Firefox on a desktop
    const browser_check = {
      timeline: [
        {
          type: jsPsychBrowserCheck,
          inclusion_function: (data) => {
        // Accept only if browser is Chrome or Firefox and not on mobile
            return ['chrome', 'firefox'].includes(data.browser) && data.mobile === false;
          },
          exclusion_message: (data) => {
            aborted = true;
            if (data.mobile) {
              return '<p>You must use a desktop/laptop computer to participate in this experiment.</p>';
            } else if (!['chrome','firefox'].includes(data.browser)) {
              return '<p>You must use Chrome or Firefox as your browser to complete this experiment.</p>';
            }
          }
        }
      ],
      conditional_function: function() {
    // Skip this check if pilot mode
        if (pilot === 'true') {
          return false;
        } 
        return true;
      }
    };

// Request participant enter fullscreen
    const enter_fullscreen = {
      timeline: [
        {
          type: jsPsychFullscreen,
          message: '<p>To take part in the experiment, your browser must be in fullscreen mode. Exiting fullscreen mode will pause the experiment.<br><br>Please click the button below to enable fullscreen and continue.</p>',
          fullscreen_mode: true,
          on_finish: function(){
            in_fullscreen = true;
          }
        }
      ],
      conditional_function: function() {
    // Skip if pilot
        if (pilot === 'true') {
          return false;
        } 
        return true;
      }
    };

/* 
  ===============================================================
  =                     DOT TRIAL PROCEDURE                      =
  ===============================================================
*/


    var dot_trial = {
      timeline: [

          /* Fixation cross */
        {
          type: jsPsychHtmlKeyboardResponse,
          stimulus: '<p style = "font-size: 70pt;">+</p>',
          choices: "NO_KEYS",
          trial_duration: 1000
        },

          /* Stimulus presentation (brief) */

        {
          type: jsPsychCanvasKeyboardResponse,
          canvas_size: [800, 1000],
          stimulus: function(c){

          // Set up the dot counts.
        var baseline = 313;  // half-filled box (313 dots)
        // Choose a random increment between 1 and 70.
        var increment = Math.round(70 * Math.exp(staircase.current_log - 4.2));
        var highCount = baseline + increment;

        // Randomly assign the higher dot count to the left or right box.
        var leftDots, rightDots;
        if (Math.random() < 0.5) {
          leftDots = highCount;
          rightDots = baseline;
        } else {
          leftDots = baseline;
          rightDots = highCount;
        }


      // Determine the correct response key.
        var correct_key;
        if (leftDots > rightDots) {
          correct_key = 'w';
          target_left = true;
        } else {
          correct_key = 'e';
          target_left = false;
        }
            // Save these values for later use.
        window.current_trial_dots = {
          leftDots: leftDots,
          rightDots: rightDots,
          baseline: baseline,
          increment: increment,
          correct_key: correct_key,
          target_left: target_left
        };


        return drawStimuli(c, true, "black", "black", leftDots, rightDots);
      },
      trial_duration: 300,
      choices: "NO_KEYS",
      on_finish: function(data){
        data.trial_type = "Stimulus Presentation";

        // Retrieve the values from the temporary storage and add them to the trial data.
        data.leftDots   = window.current_trial_dots.leftDots;
        data.rightDots  = window.current_trial_dots.rightDots;
        data.baseline   = window.current_trial_dots.baseline;
        data.increment  = window.current_trial_dots.increment;
        data.correct_key = window.current_trial_dots.correct_key;
        data.target_left = window.current_trial_dots.target_left;
        data.current_log = staircase.current_log;

      }
    },


    /* Response (which side had more dots) */
    {
      type: jsPsychCanvasKeyboardResponse,
      canvas_size: [800, 1000],
      stimulus: function(c){
        return drawStimuli(c, false, "black", "black");
      },
      choices: ['w', 'e'],
      on_finish: function(data) {
        data.trial_type = "Stimulus Response";

        // Score the accuracy of the response
        if(data.response == window.current_trial_dots.correct_key){
          data.correct = 1;
        } else {
          data.correct = 0;
        }

     // Clean up the temporary variable.
        delete window.current_trial_dots;

      }
    },

      /* Response highlight (blue outline) if no feedback is provided */

    {
      type: jsPsychCanvasKeyboardResponse,
      canvas_size: [800, 1000],
      trial_duration: 500,
      stimulus: function(c){
        // Store last response and correct
        const lastResponse = jsPsych.data.get().filter({trial_type: "Stimulus Response"}).last(1).values()[0].response;
        const lastCorrect = jsPsych.data.get().filter({trial_type: "Stimulus Response"}).last(1).values()[0].correct;
        if(provide_feedback == false) feedbackColor = "blue"; // colour if no feedback
        if(provide_feedback == true && lastCorrect == 1) feedbackColor = "green"; // colour if feedback and correct
        if(provide_feedback == true && lastCorrect == 0) feedbackColor = "red"; //colour if feedback and incorrect

        if (lastResponse === "e") {
          return drawStimuli(c, false, "black", feedbackColor);
        } else {
          return drawStimuli(c, false, feedbackColor, "black");
        }

      },
      choices: "NO_KEYS",
      on_finish: function(data) {
        data.trial_type = "Feedback";
      }
    },


      /* Confidence Rating */

    {
      timeline: [
        {
         type: jsPsychHtmlSliderResponse,
         stimulus: `<h3>Rate your confidence:</h3>
            <div id="conf1" class="conf" style="height:25px; width:154px; margin-top:2px; margin-left:15px;"></div>
            <div id="conf2" class="conf" style="height:25px; width:154px; margin-top:2px; margin-left:169px;"></div>
            <div id="conf3" class="conf" style="height:25px; width:154px; margin-top:2px; margin-left:323px;"></div>
            <div id="conf4" class="conf" style="height:25px; width:154px; margin-top:2px; margin-left:477px;"></div>
         <div id="conf5" class="conf" style="height:25px; width:154px; margin-top:2px; margin-left:631px;"></div>`,
         min: 1,
         max: 6,
         step: 1,
         slider_width: 800,
         require_movement: true,
         labels: ['Guessing', '', '', '', '', 'Certain'],
         button_label: "Submit",
         on_finish: function(data) {
          data.trial_type = "Confidence Rating";
        },
        css_classes: ["conf_rating"],
        on_load: function() {
            // Center the slider
          const w = window.innerWidth;
          const marLeft = (w - 800) / 2;
          document.getElementById("conf1").style.left = marLeft + "px";
          document.getElementById("conf2").style.left = marLeft + "px";
          document.getElementById("conf3").style.left = marLeft + "px";
          document.getElementById("conf4").style.left = marLeft + "px";
          document.getElementById("conf5").style.left = marLeft + "px";
        }
      }
    ],
    conditional_function: function() {
        // Only provide feedback in practice
      return phase == "Test";
    }
  },




        /* Summary trial: store main data and handle the staircase updating. 
       This doesn't display anything to the participant. */
  {
    type: jsPsychCallFunction,
    func: function() {

      // Staircase  ****-------------***

       // Determine if the response was correct.
      const lastResp = jsPsych.data.get().filter({trial_type: "Stimulus Response"}).last(1).values()[0];
      var correct = lastResp.correct;


        // Determine the current step-size (in log-space) based on trial number.
      if (trialnum <= 5) {
        step_size = 0.4;
      } else if (trialnum <= 10) {
        step_size = 0.2;
      } else {
        step_size = 0.1;
      }

        // Update the staircase following the two-down one-up rule:
      if (correct) {
        staircase.consecutive_correct += 1;
        if (staircase.consecutive_correct >= 2) {
            // Two correct in a row: make the task harder by reducing dot difference.
          staircase.current_log -= step_size;
            staircase.consecutive_correct = 0;  // Reset counter.
          }
        } else {
          // Incorrect: make the task easier.
          staircase.current_log += step_size;
          staircase.consecutive_correct = 0;
        }

        console.log("Trial:", trialnum, 
          "| Correct:", correct, 
          "| Updated log:", staircase.current_log);


      },
      on_finish: function(data) {
        // Save relevant trial data into the summary trial itself
        const lastResp = jsPsych.data.get().filter({trial_type: "Stimulus Response"}).last(1).values()[0];
        data.rt        = lastResp.rt;          // Reaction time
        data.phase     = phase;                // Practice or Test
        data.response  = lastResp.response;    // 'e' or 'w'
        data.correct   = lastResp.correct;     // 1 or 0
        const lastPres = jsPsych.data.get().filter({trial_type: "Stimulus Presentation"}).last(1).values()[0];
        data.target_left = lastPres.target_left; // target was left
        data.leftDots   = lastPres.leftDots; // dots on the left
        data.rightDots  = lastPres.rightDots; // dots on the right
        data.dot_difference  = lastPres.increment; // dot difference
        data.current_log = lastPres.current_log // dot difference in log space

        if(phase == "Test") {const lastConf = jsPsych.data.get().filter({trial_type: "Confidence Rating"}).last(1).values()[0];
        data.confidence = lastConf.response;
      }
      data.trial_type = "Summary Trial";
      trialnum++;

    }
  }

]
}







/* 
  ===============================================================
  =           BLOCKS (PRACTICE & TEST) DEFINITION               =
  ===============================================================
*/

// Define a single practice block trial (with feedback)
const practice_block_trial = {
  timeline: [dot_trial],
  repetitions: no_practice_trials, 
  on_timeline_start: function() {
    provide_feedback = true;
    phase = "Practice";
  }
};

// Define a single test block (no feedback, confidence rating)
const test_block_trial = {
  timeline: [dot_trial],
  repetitions: no_trials , 
  on_timeline_start: function() {
    provide_feedback = false;
    phase = "Test";
  }
};


// Define Practice Block
const practice_block = {
  timeline: [practice_block_trial, practice_end],
  on_timeline_start: function() {
    provide_feedback = true;
    phase = "Practice";
  }
};

// Define aTest Block
const test_blocks = {
  timeline: [new_block, test_block_trial],
  repetitions: total_blocks , 
  on_timeline_start: function() {
    provide_feedback = false;
    phase = "Test";
  }
};




/* 
  ===============================================================
  =                    FINAL DEBRIEF & SAVE                     =
  ===============================================================
*/

// Optional debug question: Issues encountered?
const debug = {
  type: jsPsychSurveyText,
  questions: [
    {prompt: 'Did you experience any issues while completing this study?', rows: 5}
  ]
};

// Capture URL parameters (Prolific, SONA, pilot, etc.)
const PROLIFIC_PID = jsPsych.data.getURLVariable('PROLIFIC_PID');
const SONAID       = jsPsych.data.getURLVariable('SONAID');
const pilot        = jsPsych.data.getURLVariable('pilot');

// Decide how to redirect user depending on whether they're from SONA or Prolific
let redirect_link, attention_redirect_link;

if (typeof SONAID !== 'undefined') {
  // SONA
  jsPsych.data.addProperties({ participant_id: SONAID, Source: "SONA" });
  redirect_link = `https://sydneypsych.sona-systems.com/webstudy_credit.aspx?experiment_id=${sona_experiment_id}&credit_token=${sona_credit_token}&survey_code=${SONAID}&id=${SONAID}`;
  attention_redirect_link = `https://sydney.au1.qualtrics.com/jfe/form/SV_3h2qh8pBAnv00QK?SONAID=${SONAID}accuracy=`;
} else {
  // Prolific
  jsPsych.data.addProperties({ participant_id: PROLIFIC_PID, Source: "Prolific" });
  redirect_link = `https://app.prolific.com/submissions/complete?cc=${Prolific_redirect}`;
  attention_redirect_link = `https://app.prolific.co/submissions/complete?cc=${Prolific_failed_check}`;
}

// Filename and location to save data
const subject_id = jsPsych.randomization.randomID(10);
const filename   = `participant-${subject_id}_data.csv`;

// We use jsPsychPipe to save to OSF (or another DataPipe-supported platform)
const save_data = {
  type: jsPsychPipe,
  action: "save",
  experiment_id: DataPipe_ID,
  filename: filename,
  data_string: () => jsPsych.data.get().csv()
};





/* 
  ===============================================================
  =                 BUILD AND RUN THE EXPERIMENT                =
  ===============================================================
*/

/**
 * Full timeline for Condition 1. 
 * (You can create separate timelines/conditions if desired.)
 */
const condition_1_timeline = [
  browser_check,
  enter_fullscreen,
  participant_info_paid,  // from info_sheets.js 
  participant_info_SONA,  // from info_sheets.js
  demographics,           // from info_sheets.js
  instructions,
  practice_block,
  conf_instruc, 
  test_start,
  test_blocks,
  debug,
  save_data,
  DEBRIEF_SONA   
];



/**
 * Asynchronously fetches a 'condition' from DataPipe (if needed),
 * then runs the corresponding timeline. If you do not use multiple
 * conditions, you could simply run condition_1_timeline directly.
 */
async function createExperiment() {
  const condition = await jsPsychPipe.getCondition(DataPipe_ID);
  jsPsych.data.addProperties({ condition: condition });

  // If you have different conditions, you could add them here:
  if (condition == 0 || condition == 1) {
    jsPsych.run(condition_1_timeline);
  } else {
    // Default fallback
    jsPsych.run(condition_1_timeline);
  }


}

// Start the experiment
createExperiment();

</script>
</html>
